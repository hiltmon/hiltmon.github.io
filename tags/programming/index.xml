<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on Hiltmon</title><link>https://hiltmon.com/tags/programming/</link><description>Recent content in Programming on Hiltmon</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 25 Mar 2016 08:57:53 -0400</lastBuildDate><atom:link href="https://hiltmon.com/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Dependency Limited and Conflict Free C++</title><link>https://hiltmon.com/blog/2016/03/25/dependency-limited-and-conflict-free-c-plus-plus/</link><pubDate>Fri, 25 Mar 2016 08:57:53 -0400</pubDate><guid>https://hiltmon.com/blog/2016/03/25/dependency-limited-and-conflict-free-c-plus-plus/</guid><description>TL;DR: Beware of libraries you need to compile yourself and copy-pasted code, the performance, maintenance and other hellscapes you create are not worth it in the medium and long run:
Do not use dependencies that have dependencies that you have to compile. Do not use libraries depended on by dependencies anywhere else. Solve your own problems and understand the solutions. Do not copy-paste from the web. Always write your own code where performance and maintenance is critical.</description></item><item><title>C++11 on CentOS 6.6</title><link>https://hiltmon.com/blog/2015/08/09/c-plus-plus-11-on-centos-6-dot-6/</link><pubDate>Sun, 09 Aug 2015 18:07:25 -0400</pubDate><guid>https://hiltmon.com/blog/2015/08/09/c-plus-plus-11-on-centos-6-dot-6/</guid><description>As mentioned in previous articles, I write a lot of C++11 code on OS X but deploy it on CentOS Linux 6.6 servers. But CentOS 6.6 does not contain a C++11 development environment by default.
Here&amp;rsquo;s how to set one up.
Install a C++11 Compiler We need to get the repo files for DevTools2, a Red Hat package that contains a supported C++11 compiler. As root, run the following command to retrieve the repo file:</description></item><item><title>Simple C++: From Makefiles to Xcode Builds</title><link>https://hiltmon.com/blog/2015/08/01/simple-c-plus-plus-from-makefiles-to-xcode-builds/</link><pubDate>Sat, 01 Aug 2015 11:25:51 -0400</pubDate><guid>https://hiltmon.com/blog/2015/08/01/simple-c-plus-plus-from-makefiles-to-xcode-builds/</guid><description>&lt;p>This post will present a step-by-step process to convert C++/C++11 Makefile-based projects to Xcode build tools. I use it all the time to set up, convert, build and debug Unix/Linux executables that I develop on my Macintosh.&lt;/p></description></item><item><title>Simple C++ Testing with Catch in Xcode</title><link>https://hiltmon.com/blog/2014/10/26/simple-c-plus-plus-testing-with-catch-in-xcode/</link><pubDate>Sun, 26 Oct 2014 14:34:32 -0400</pubDate><guid>https://hiltmon.com/blog/2014/10/26/simple-c-plus-plus-testing-with-catch-in-xcode/</guid><description>Catch is a simple, open-source, dependency-free unit testing framework for C++ projects. In this post I show you how to use it in a Simple C++ Project from Xcode.
Why Catch? I am writing fast C++ libraries for work and need to wrap them in unit tests to ensure that they continue to operate and perform as they evolve. My number one constraint is that these libraries must be dependency-free.</description></item><item><title>Xcode 4 Code Completion for External Build Projects</title><link>https://hiltmon.com/blog/2013/07/07/xcode-4-code-completion-for-external-build-projects/</link><pubDate>Sun, 07 Jul 2013 21:53:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/07/xcode-4-code-completion-for-external-build-projects/</guid><description>In Xcode and the Simple C++ Project Structure, I showed how to set up Xcode as your IDE for the Simple C++ Project Structure.
But one thing does not work, Code Sense. Xcode does not provide code completion or jump to definition for these projects.
Wouldn&amp;rsquo;t it be nice if we could enable this too.
The solution is simple, you need to use the Xcode build system to create the indices that the IDE uses.</description></item><item><title>Xcode and the Simple C++ Project Structure</title><link>https://hiltmon.com/blog/2013/07/05/xcode-and-the-simple-c-plus-plus-project-structure/</link><pubDate>Fri, 05 Jul 2013 11:31:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/05/xcode-and-the-simple-c-plus-plus-project-structure/</guid><description>In a previous post, I talked about a A Simple C++ Project Structure that I am using to create a bunch of high-speed daemons for work.
It&amp;rsquo;s been fun using TextMate 2 and a Terminal to make and run the project, but now that I am getting to the meat of the coding, I&amp;rsquo;d prefer to use an IDE to help me navigate and debug the code.
Here&amp;rsquo;s how to set up Xcode 4 on the Mac to compile using our Makefile and run/debug the application.</description></item><item><title>Using the Spike Folder</title><link>https://hiltmon.com/blog/2013/07/04/using-the-spike-folder/</link><pubDate>Thu, 04 Jul 2013 17:48:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/04/using-the-spike-folder/</guid><description>In yesterday&amp;rsquo;s post A Simple C++ Project Structure, I mentioned the spike folder. In today&amp;rsquo;s post, I&amp;rsquo;ll write more about how I use it.
By the way, I have previously written about spike solutions, wherein I create solutions for the bigger technical problems at the start of a project to be sure they are achievable. This is different.
In this case, being back in C++ and rusty as an old door hinge, I also needed to create and test out snippets of code I could be using without having to make and run the entire product.</description></item><item><title>A Simple C++ Project Structure</title><link>https://hiltmon.com/blog/2013/07/03/a-simple-c-plus-plus-project-structure/</link><pubDate>Wed, 03 Jul 2013 22:33:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/03/a-simple-c-plus-plus-project-structure/</guid><description>One of the things I need in my new job is a bunch of blazingly fast daemons to capture market information and trade data. I prototyped them in Ruby to see what comes down the line, but I have the need, the need for speed. Which means I need a UNIX C or C++ framework.
So I went old-school. Retro even. Plain old C++. My favorite programmer&amp;rsquo;s editor. And the good old terminal, er, iTerm 2, just Mac-like.</description></item><item><title>My Next Product</title><link>https://hiltmon.com/blog/2013/05/13/my-next-product/</link><pubDate>Mon, 13 May 2013 10:56:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/05/13/my-next-product/</guid><description>My next product is going to be the best product I ever made. Of this I am certain.
It is going to have an absolutely beautiful design inside and out. The internal architecture is going to be sublime, the code and classes readable and maintainable. The functionality in the first version will hit all the high marks and the UI is going to stand out.
My next product is going to solve a problem that lots of other people face every day.</description></item><item><title>Reprogramming my Brace Style Mind</title><link>https://hiltmon.com/blog/2013/01/07/reprogramming-my-brace-style-mind/</link><pubDate>Mon, 07 Jan 2013 13:24:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/01/07/reprogramming-my-brace-style-mind/</guid><description>Each and every programmer has their own style of coding, their own preferences for how code should look, and are generally happy to argue the case for their preference. Somehow these discussions became heated, and the most fights happen over spaces vs tabs (See Tabs versus Spaces: An Eternal Holy War. and Death to the Space Infidels!), the 80 column rule (See In defense of the 80-column rule) and brace indent style.</description></item></channel></rss>