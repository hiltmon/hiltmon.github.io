<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on Hiltmon</title><link>https://hiltmon.com/tags/c++/</link><description>Recent content in c++ on Hiltmon</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 09 Feb 2019 13:55:39 -0500</lastBuildDate><atom:link href="https://hiltmon.com/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing C++17 Projects in Xcode with XCTest</title><link>https://hiltmon.com/blog/2019/02/09/testing-c-plus-plus-17-project-in-xcode-with-xctest/</link><pubDate>Sat, 09 Feb 2019 13:55:39 -0500</pubDate><guid>https://hiltmon.com/blog/2019/02/09/testing-c-plus-plus-17-project-in-xcode-with-xctest/</guid><description>The vast majority of development I perform is in C++17 on an Apple Mac Computer using Xcode. For a while now, I have been using Catch2 as my Unit Testing framework, and its absolutely excellent. But its not integrated into the Xcode IDE and I wanted the ability to use Xcode&amp;rsquo;s excellent testing and test debugging tools to improve my productivity and workflow.
In this post I will show you how to set up a simple standard C++17 library project in Xcode 10 and then add XCTests to it.</description></item><item><title>Dependency Limited and Conflict Free C++</title><link>https://hiltmon.com/blog/2016/03/25/dependency-limited-and-conflict-free-c-plus-plus/</link><pubDate>Fri, 25 Mar 2016 08:57:53 -0400</pubDate><guid>https://hiltmon.com/blog/2016/03/25/dependency-limited-and-conflict-free-c-plus-plus/</guid><description>TL;DR: Beware of libraries you need to compile yourself and copy-pasted code, the performance, maintenance and other hellscapes you create are not worth it in the medium and long run:
Do not use dependencies that have dependencies that you have to compile. Do not use libraries depended on by dependencies anywhere else. Solve your own problems and understand the solutions. Do not copy-paste from the web. Always write your own code where performance and maintenance is critical.</description></item><item><title>The Simple C++ Makefile - Executable Edition</title><link>https://hiltmon.com/blog/2015/09/28/the-simple-c-plus-plus-makefile-executable-edition/</link><pubDate>Mon, 28 Sep 2015 22:07:23 -0400</pubDate><guid>https://hiltmon.com/blog/2015/09/28/the-simple-c-plus-plus-makefile-executable-edition/</guid><description>I develop a lot of applications in C++ using Xcode on OS X and deploy them to CentOS Linux Servers to run. I follow the Simple C++ Project Structure (and the Xcode edition) to code up each product.
However, Xcode is not available on Linux. To compile and deploy (and to test compiles and deploys), I use standard Unix Makefiles, available almost everywhere.
In this post I will show you the Makefile I use for multi-platform C++ executable builds and explain what each line and command does in detail.</description></item><item><title>C++11 on CentOS 6.6</title><link>https://hiltmon.com/blog/2015/08/09/c-plus-plus-11-on-centos-6-dot-6/</link><pubDate>Sun, 09 Aug 2015 18:07:25 -0400</pubDate><guid>https://hiltmon.com/blog/2015/08/09/c-plus-plus-11-on-centos-6-dot-6/</guid><description>As mentioned in previous articles, I write a lot of C++11 code on OS X but deploy it on CentOS Linux 6.6 servers. But CentOS 6.6 does not contain a C++11 development environment by default.
Here&amp;rsquo;s how to set one up.
Install a C++11 Compiler We need to get the repo files for DevTools2, a Red Hat package that contains a supported C++11 compiler. As root, run the following command to retrieve the repo file:</description></item><item><title>Simple C++: From Makefiles to Xcode Builds</title><link>https://hiltmon.com/blog/2015/08/01/simple-c-plus-plus-from-makefiles-to-xcode-builds/</link><pubDate>Sat, 01 Aug 2015 11:25:51 -0400</pubDate><guid>https://hiltmon.com/blog/2015/08/01/simple-c-plus-plus-from-makefiles-to-xcode-builds/</guid><description>&lt;p>This post will present a step-by-step process to convert C++/C++11 Makefile-based projects to Xcode build tools. I use it all the time to set up, convert, build and debug Unix/Linux executables that I develop on my Macintosh.&lt;/p></description></item><item><title>Write Timestamps containing Milliseconds to MongoDB in C++11</title><link>https://hiltmon.com/blog/2015/01/14/write-timestamps-containing-millisecond-to-mongodb-in-c-plus-plus-11/</link><pubDate>Wed, 14 Jan 2015 18:42:40 -0500</pubDate><guid>https://hiltmon.com/blog/2015/01/14/write-timestamps-containing-millisecond-to-mongodb-in-c-plus-plus-11/</guid><description>It took me several hours today to figure this one out, so I thought I&amp;rsquo;d write it up lest I forget.
I have a C++11 application that rapidly writes new documents to a MongoDB instance and I need high-resolution timestamps to determine the order things were written.
The problem is that the C++ standard time_t structure reports in seconds, so
builder.appendTimeT(&amp;#34;updated_at&amp;#34;, std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) ); creates an ISODate without milliseconds in MongoDB.</description></item><item><title>Simple C++ Testing with Catch in Xcode</title><link>https://hiltmon.com/blog/2014/10/26/simple-c-plus-plus-testing-with-catch-in-xcode/</link><pubDate>Sun, 26 Oct 2014 14:34:32 -0400</pubDate><guid>https://hiltmon.com/blog/2014/10/26/simple-c-plus-plus-testing-with-catch-in-xcode/</guid><description>Catch is a simple, open-source, dependency-free unit testing framework for C++ projects. In this post I show you how to use it in a Simple C++ Project from Xcode.
Why Catch? I am writing fast C++ libraries for work and need to wrap them in unit tests to ensure that they continue to operate and perform as they evolve. My number one constraint is that these libraries must be dependency-free.</description></item><item><title>An Xcode C++ Client-Server Development Trick</title><link>https://hiltmon.com/blog/2014/07/30/an-xcode-c-plus-plus-client-server-development-trick/</link><pubDate>Wed, 30 Jul 2014 19:57:01 -0400</pubDate><guid>https://hiltmon.com/blog/2014/07/30/an-xcode-c-plus-plus-client-server-development-trick/</guid><description>I&amp;rsquo;m working on a C++ product that has a series of client executables that need to talk to a server executable. And they all share a lot of common code.
The traditional approach to build and debug this pattern is to create a library of the common code in one project, a separate server project and another client project, then jump between windows to edit and compile where needed.
But I am often coding on my trusty 13&amp;quot; MacBook Air screen and it&amp;rsquo;s just too tiny to have all these Xcode windows open with their console windows visible.</description></item><item><title>Xcode 4 Code Completion for External Build Projects</title><link>https://hiltmon.com/blog/2013/07/07/xcode-4-code-completion-for-external-build-projects/</link><pubDate>Sun, 07 Jul 2013 21:53:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/07/xcode-4-code-completion-for-external-build-projects/</guid><description>In Xcode and the Simple C++ Project Structure, I showed how to set up Xcode as your IDE for the Simple C++ Project Structure.
But one thing does not work, Code Sense. Xcode does not provide code completion or jump to definition for these projects.
Wouldn&amp;rsquo;t it be nice if we could enable this too.
The solution is simple, you need to use the Xcode build system to create the indices that the IDE uses.</description></item><item><title>Xcode and the Simple C++ Project Structure</title><link>https://hiltmon.com/blog/2013/07/05/xcode-and-the-simple-c-plus-plus-project-structure/</link><pubDate>Fri, 05 Jul 2013 11:31:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/05/xcode-and-the-simple-c-plus-plus-project-structure/</guid><description>In a previous post, I talked about a A Simple C++ Project Structure that I am using to create a bunch of high-speed daemons for work.
It&amp;rsquo;s been fun using TextMate 2 and a Terminal to make and run the project, but now that I am getting to the meat of the coding, I&amp;rsquo;d prefer to use an IDE to help me navigate and debug the code.
Here&amp;rsquo;s how to set up Xcode 4 on the Mac to compile using our Makefile and run/debug the application.</description></item><item><title>Using the Spike Folder</title><link>https://hiltmon.com/blog/2013/07/04/using-the-spike-folder/</link><pubDate>Thu, 04 Jul 2013 17:48:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/04/using-the-spike-folder/</guid><description>In yesterday&amp;rsquo;s post A Simple C++ Project Structure, I mentioned the spike folder. In today&amp;rsquo;s post, I&amp;rsquo;ll write more about how I use it.
By the way, I have previously written about spike solutions, wherein I create solutions for the bigger technical problems at the start of a project to be sure they are achievable. This is different.
In this case, being back in C++ and rusty as an old door hinge, I also needed to create and test out snippets of code I could be using without having to make and run the entire product.</description></item><item><title>A Simple C++ Project Structure</title><link>https://hiltmon.com/blog/2013/07/03/a-simple-c-plus-plus-project-structure/</link><pubDate>Wed, 03 Jul 2013 22:33:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/07/03/a-simple-c-plus-plus-project-structure/</guid><description>One of the things I need in my new job is a bunch of blazingly fast daemons to capture market information and trade data. I prototyped them in Ruby to see what comes down the line, but I have the need, the need for speed. Which means I need a UNIX C or C++ framework.
So I went old-school. Retro even. Plain old C++. My favorite programmer&amp;rsquo;s editor. And the good old terminal, er, iTerm 2, just Mac-like.</description></item><item><title>Reprogramming my Brace Style Mind</title><link>https://hiltmon.com/blog/2013/01/07/reprogramming-my-brace-style-mind/</link><pubDate>Mon, 07 Jan 2013 13:24:00 -0400</pubDate><guid>https://hiltmon.com/blog/2013/01/07/reprogramming-my-brace-style-mind/</guid><description>Each and every programmer has their own style of coding, their own preferences for how code should look, and are generally happy to argue the case for their preference. Somehow these discussions became heated, and the most fights happen over spaces vs tabs (See Tabs versus Spaces: An Eternal Holy War. and Death to the Space Infidels!), the 80 column rule (See In defense of the 80-column rule) and brace indent style.</description></item></channel></rss>